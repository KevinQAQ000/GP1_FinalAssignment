using System.Collections;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.SceneManagement;

/// <summary>
/// Character player controller
/// </summary>
public class PlayerController : MonoBehaviour
{
    public CharacterController characterController;
    public Vector3 moveDirection; // Character movement direction
    private AudioSource audioSource;
    private Vector3 impactVelocity; // Instantaneous velocity generated by impact

    private float verticalVelocity; // Specialized for handling y-axis speed
    private Vector3 airControlDirection; // Record the direction at the moment of takeoff

    [Header("Player Stats")]
    public float Speed; // Current speed
    public float walkSpeed; // Walking speed
    public float runSpeed; // Running speed
    public float crouchSpeed; // Crouching speed
    public float playerHealth; // Player health points
    public float jumpForce; // Jumping force
    public float fallForce; // Falling speed/gravity
    public float crouchHeight; // Height while crouching
    public float standHeight; // Height while standing

    [Header("Key Bindings")]
    public KeyCode runInputName = KeyCode.LeftShift; // Run key
    public KeyCode jumpInputName = KeyCode.Space; // Jump key
    public KeyCode crouchInputName = KeyCode.LeftControl; // Crouch key

    [Header("Player Status Flags")]
    public MovementState state; // Character movement state
    public CollisionFlags collisionFlags; // Collision flags
    public bool isWalk; // Is walking
    public bool isRun; // Is running
    public bool isJump; // Is jumping
    public bool isGround; // Is grounded
    public bool isCanCrouch; // Can the player crouch/stand up
    public bool isCouching; // Is currently crouching
    public bool isBlocked; // Is the head blocked by an obstacle
    public bool playerisDead; // Is the player dead
    private bool isDamage; // Did the player take damage
    public GameObject YouDied; // Death UI display

    public LayerMask crouchLayerMask; // Layer mask for obstacle detection above head
    public Text playerHealthUI; // Player health UI text
    public Image hurtImage; // Damage flash image
    private Color flashColor = new Color(1f, 0f, 0f, 0.5f); // Damage flash color
    private Color clearColor = Color.clear; // Transparent color

    [Header("SFX")]
    public AudioClip walkSound; // Walking sound effect
    public AudioClip runSound; // Running sound effect

    [Header("Win Logic")]
    public GameObject YouWinUI; // Victory UI panel
    public string winTagName = "WinObject"; // Tag for the victory trigger object
    private float winTimer = 0f; // Timer for capture/win progress
    private bool playerWon = false; // Has the player won

    [Header("Falling Death Settings")]
    public float deathYThreshold = -10f; // Y-depth that triggers "fell off cliff"
    private float fallTimer = 0f; // Falling timer

    private Vector3 lastDeathPosition; // Records coordinates at the time of death

    void Start()
    {
        characterController = GetComponent<CharacterController>(); // Get CharacterController component
        audioSource = GetComponent<AudioSource>(); // Get AudioSource component
        walkSpeed = 4f;
        runSpeed = 6f;
        jumpForce = 0f;
        fallForce = 15f;
        crouchSpeed = 3f;
        crouchHeight = 1.2f;
        playerHealth = 100f;
        standHeight = characterController.height;
        playerHealthUI.text = "Hp:" + playerHealth;

        // Ensure Death UI is hidden at start
        if (YouDied != null)
        {
            YouDied.gameObject.SetActive(false);
        }
        if (YouWinUI != null) YouWinUI.SetActive(false);
    }

    private bool isTouchingWinObject = false; // Variable: is currently touching win object
    private Vector3 lastSafeGroundPosition;

    void Update()
    {
        // Red flash effect on screen after player takes damage
        if (isDamage)
        {
            hurtImage.color = flashColor;
        }
        else
        {
            hurtImage.color = Color.Lerp(hurtImage.color, clearColor, 5f * Time.deltaTime); // Gradually fade out red
        }
        isDamage = false;

        if (playerisDead)
        {
            // Game over, stop all operations
            return;
        }

        CheckFallDeath();

        playerHealthUI.text = "Hp:" + playerHealth;
        isCanCrouch = CanCrouch(); // Determine if the player can crouch/stand up
        CheckGroundStatus(); // Optimized ground detection
        Vector3 finalMovement = CalculateMovement();
        characterController.Move(finalMovement * Time.deltaTime);

        if (Input.GetKey(crouchInputName))
        {
            Crouch(true);
        }
        else
        {
            if (isCanCrouch)
            {
                Crouch(false);
            }
            else
            {
                // Stuck, maintain crouched state
                isCouching = true;
            }
        }

        Jump();
        PlayerFootSoundSet();
        Moving();

        if (playerWon) return;

        // Win timer logic
        if (isTouchingWinObject)
        {
            winTimer += Time.deltaTime;
            Debug.Log("Capturing... Progress: " + (winTimer / 5f * 100f).ToString("F0") + "%");

            if (winTimer >= 5f)
            {
                WinGame();
            }
        }
        else
        {
            // Timer slowly recedes after leaving the area
            winTimer = Mathf.Max(0, winTimer - Time.deltaTime);
        }

        if (isGround && !playerisDead && !isCouching)
        {
            lastDeathPosition = transform.position;
            lastSafeGroundPosition = transform.position;
        }
    }

    public void RespawnAtSafePoint()
    {
        ResetStatus(lastDeathPosition);
    }

    /// <summary>
    /// Detects falling off the cliff logic
    /// </summary>
    private void CheckFallDeath()
    {
        // If Y-coordinate is below threshold
        if (transform.position.y < deathYThreshold)
        {
            fallTimer += Time.deltaTime;
            // Print debug info once per second
            if (fallTimer > 0) Debug.Log("Falling... " + fallTimer.ToString("F1") + "s");

            if (fallTimer >= 3f)
            {
                Die();
                fallTimer = 0f; // Reset after trigger
            }
        }
        else
        {
            // Reset timer when in safe area
            fallTimer = 0f;
        }
    }

    public void Moving() // Character movement method
    {
        // Get raw input for immediate stop response
        float h = Input.GetAxisRaw("Horizontal");
        float v = Input.GetAxisRaw("Vertical");

        isRun = Input.GetKey(runInputName); // Get run key input
        isWalk = (Mathf.Abs(h) > 0 || Mathf.Abs(v) > 0); // Determine if walking

        if (isGround)
        {
            // Priority: Crouch > Run > Walk
            if (isCouching)
            {
                state = MovementState.Crouching;
                Speed = crouchSpeed;
            }
            else if (isRun) // Run only if not crouching and Shift is held
            {
                state = MovementState.Running;
                Speed = runSpeed;
            }
            else
            {
                state = MovementState.Walking;
                Speed = walkSpeed;
            }
        }

        // Calculate movement direction and normalize to prevent faster diagonal movement
        moveDirection = (transform.right * h + transform.forward * v).normalized;
        characterController.Move(moveDirection * Speed * Time.deltaTime);
    }

    public void Jump() // Character jumping method
    {
        if (!isCanCrouch) return;
        isJump = Input.GetKeyDown(jumpInputName); // Get jump input

        if (isJump && isGround) // Jump if grounded
        {
            isGround = false;
            verticalVelocity = 5f; // Initial jump force
        }
        else if (!isGround && isGround)
        {
            isGround = false;
        }

        if (!isGround)
        {
            jumpForce -= fallForce * Time.deltaTime; // Falling speed/Gravity
            Vector3 jump = new Vector3(0, jumpForce * Time.deltaTime, 0); // Convert jump force to Vector3
            collisionFlags = characterController.Move(jump * Time.deltaTime); // Use Move to simulate jumping up

            if (collisionFlags == CollisionFlags.Below) // Check for landing
            {
                isGround = true;
                jumpForce = -2f;
            }
        }
    }

    /// <summary>
    /// Determines if the player can stand up from a crouch
    /// isCanCrouch = true: No obstacle above, can stand
    /// isCanCrouch = false: Obstacle above head
    /// </summary>
    public bool CanCrouch()
    {
        // Detection point: From base up to (Stand Height - Sphere Radius)
        // This puts the sphere exactly at "head level" when standing
        Vector3 sphereLocation = transform.position + Vector3.up * (standHeight - characterController.radius);

        float checkRadius = characterController.radius * 1.2f;
        // Detect if head is blocked
        isBlocked = Physics.CheckSphere(sphereLocation, checkRadius, crouchLayerMask);

        return !isBlocked;
    }

    public void Crouch(bool newCrouching) // Character crouch method
    {
        isCouching = newCrouching; // Set crouch state
        characterController.height = isCouching ? crouchHeight : standHeight; // Set height based on state
        characterController.center = Vector3.up * (characterController.height / 2f); // Adjust center based on height

        if (isCouching)
            state = MovementState.Crouching;
    }

    private void OnDrawGizmos() // Visual detection debugging
    {
        Gizmos.color = Color.blue;
        Vector3 shpereLocation = transform.position + Vector3.up * standHeight;
        Gizmos.DrawWireSphere(shpereLocation, characterController.radius);

        // Set color: Red if head is blocked, Green if clear
        Gizmos.color = CanCrouch() ? Color.green : Color.red;

        // Calculate detection sphere position (must match logic in CanCrouch)
        Vector3 sphereLocation = transform.position + Vector3.up * (standHeight - characterController.radius);

        // Draw detection range
        Gizmos.DrawWireSphere(sphereLocation, characterController.radius * 1.2f);
    }

    /// <summary>
    /// Movement sound effect logic
    /// </summary>
    public void PlayerFootSoundSet()
    {
        // sqrMagnitude returns the squared length of the vector for performance
        if (isGround && moveDirection.sqrMagnitude > 0)
        {
            audioSource.clip = isRun ? runSound : walkSound; // Set sound based on running state
            if (!audioSource.isPlaying)
            {
                audioSource.Play();
            }
        }
        else // Stop playing if not on ground or not moving
        {
            if (audioSource.isPlaying)
            {
                audioSource.Pause();
            }
        }
    }

    private void CheckGroundStatus()
    {
        // Combine CharacterController's built-in isGrounded with manual collision flags
        isGround = characterController.isGrounded || (collisionFlags & CollisionFlags.Below) != 0;
    }

    // Core movement calculation logic
    private Vector3 CalculateMovement()
    {
        float h = Input.GetAxisRaw("Horizontal");
        float v = Input.GetAxisRaw("Vertical");
        Vector3 inputDir = (transform.right * h + transform.forward * v).normalized;

        // State and speed determination
        isRun = Input.GetKey(runInputName);
        if (isCouching) Speed = crouchSpeed;
        else if (isRun) Speed = runSpeed;
        else Speed = walkSpeed;

        Vector3 horizontalMove;

        if (isGround)
        {
            // While on ground, update movement direction normally
            horizontalMove = inputDir * Speed;

            // Record current direction to serve as backup for jumps
            airControlDirection = horizontalMove;

            // Reset vertical velocity on landing (-3f keeps character pinned to slopes)
            if (verticalVelocity < 0) verticalVelocity = -3f;

            // Jump logic
            if (Input.GetKeyDown(jumpInputName) && !isBlocked)
            {
                verticalVelocity = 6f;
                isGround = false;
            }
        }
        else
        {
            // [CRITICAL] In air, use direction recorded at takeoff (prevents mid-air steering)
            horizontalMove = airControlDirection;

            // Apply gravity
            verticalVelocity -= fallForce * Time.deltaTime;
        }

        if (impactVelocity.magnitude > 0.2f)
        {
            // Add knockback impact to movement
            // Lerp causes impact to decay rapidly
            impactVelocity = Vector3.Lerp(impactVelocity, Vector3.zero, 5f * Time.deltaTime);
        }
        else
        {
            impactVelocity = Vector3.zero;
        }

        // Combine all vectors
        return new Vector3(horizontalMove.x, verticalVelocity, horizontalMove.z) + impactVelocity;
    }


    /// <summary>
    /// Handle Player Health
    /// </summary>
    /// <param name="damage">Amount of damage received</param>
    public void PlayerHealth(float damage)
    {
        if (playerisDead) return; // Prevent duplicate death logic

        playerHealth -= damage;
        isDamage = true;

        // Knockback effect upon taking damage
        impactVelocity = -transform.forward * 1.5f * 10f;

        playerHealthUI.text = "Hp: " + playerHealth;
        if (playerHealth <= 0)
        {
            Die();
        }
    }

    IEnumerator ExecuteAfterTime(float time) // Coroutine to wait specified seconds
    {
        yield return new WaitForSeconds(time);
        Debug.Log("Time is up! Executing logic.");
    }

    private void Die()
    {
        playerisDead = true;
        playerHealth = 0;
        playerHealthUI.text = "Hp: 0";

        // CORE CHANGE: If fell off cliff, use safe ground point; if killed, use current position
        if (transform.position.y < deathYThreshold)
        {
            lastDeathPosition = lastSafeGroundPosition;
        }
        else
        {
            lastDeathPosition = transform.position;
        }

        Debug.Log("Respawn position recorded: " + lastDeathPosition);

        if (YouDied != null)
        {
            YouDied.SetActive(true);
            Cursor.lockState = CursorLockMode.None;
            Cursor.visible = true;
        }

        Time.timeScale = 0f; // Pause game
    }

    public void ResetStatus(Vector3 targetPos)
    {
        Time.timeScale = 1f;
        characterController.enabled = false;

        // Safety check logic: Prevent teleporting to invalid coordinates
        if (float.IsInfinity(targetPos.x) || float.IsNaN(targetPos.x))
        {
            Debug.LogWarning("Invalid death coordinates, force respawning at default point");
            targetPos = new Vector3(0, 5, 0);
        }

        transform.position = targetPos;

        // Reset physics velocities
        verticalVelocity = 0f;
        impactVelocity = Vector3.zero;
        moveDirection = Vector3.zero;

        // Reset status flags
        playerHealth = 100f;
        playerisDead = false;
        fallTimer = 0f;

        if (playerHealthUI != null) playerHealthUI.text = "Hp: " + playerHealth;
        if (YouDied != null) YouDied.SetActive(false);

        Cursor.lockState = CursorLockMode.Locked;
        Cursor.visible = false;

        characterController.enabled = true;
    }

    /// <summary>
    /// UI Button Binding: Respawn at death location
    /// </summary>
    public void RespawnAtDeathPoint()
    {
        // Elevate spawn point by 1.5m to prevent getting stuck in the floor
        Vector3 spawnPos = lastDeathPosition + Vector3.up * 1.5f;

        // Call status reset method
        ResetStatus(spawnPos);
    }

    private void OnTriggerStay(Collider other)
    {
        if (other.CompareTag(winTagName))
        {
            isTouchingWinObject = true;
        }
    }

    private void OnTriggerExit(Collider other)
    {
        if (other.CompareTag(winTagName))
        {
            isTouchingWinObject = false;
        }
    }

    public void RestartGame()
    {
        Time.timeScale = 1f; // Must restore time scale
        SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex); // Reload current scene
    }

    private void WinGame()
    {
        playerWon = true;
        Debug.Log("You Win!");

        if (YouWinUI != null)
        {
            YouWinUI.SetActive(true);
            Time.timeScale = 0f; // Pause game
            Cursor.lockState = CursorLockMode.None;
            Cursor.visible = true;
        }
    }

    public enum MovementState // Character movement states
    {
        Walking,
        Running,
        Crouching,
        idle
    }
}